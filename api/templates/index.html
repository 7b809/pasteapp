{% extends "base.html" %}
{% block title %}Give{% endblock %}
{% block body %}
<h1 class="mb-4">Give</h1>
<!-- Normal Form -->
<form method="post" id="normalForm">
  <div class="btn-group mb-3">
    <button type="submit" class="btn btn-primary">Save</button>
    <button type="button" class="btn btn-secondary" onclick="clearContent()">
      Clear
    </button>
    <button type="button" class="btn btn-success" onclick="copyContent()">
      Copy
    </button>
    <button type="button" class="btn btn-warning" onclick="pasteContent()">
      Paste
    </button>
    <button type="button" class="btn btn-info" onclick="uploadRaw()">
      Upload Raw
    </button>
  </div>

  <textarea
    id="contentArea"
    name="content"
    class="form-control mb-3"
    rows="15"
    placeholder="Paste something here..."
  ></textarea>
</form>

<!-- -------- ZIP ‚Üî Text Converter -------- -->
<div class="card p-3 mb-4 shadow-sm">
  <h5>Zip ‚Üî Text Converter</h5>

  <!-- Zip to Text and upload -->
  <div class="mb-3">
    <label class="form-label">Upload ZIP File ‚Üí Convert & Upload as Text</label>
    <input type="file" id="zipFileInput" accept=".zip" class="form-control" />
    <button id="zipToTextBtn" class="btn btn-primary mt-2">
      Convert & Upload ZIP as Text
    </button>
  </div>

  <!-- Multi-URL Fetch ‚Üí Single ZIP -->
  <div class="mb-3">
    <label class="form-label"
      >Paste multiple URLs (one per line) ‚Üí Combined ZIP</label
    >
    <textarea
      id="pasteUrlInput"
      rows="5"
      class="form-control"
      placeholder="Enter one URL per line"
    ></textarea>
    <button id="urlToZipBtn" class="btn btn-secondary mt-2">
      Fetch & Download Combined ZIP
    </button>
  </div>

  <div id="zipStatus" class="mt-2 fw-bold"></div>
  <ul id="zipIdList" class="list-group mt-2"></ul>
  <button id="zipCopyBtn" class="btn btn-success mt-2" style="display: none">
    Copy All Paste URLs
  </button>
</div>

<!-- -------- Existing File Upload in Batches -------- -->
<div class="card p-3 mb-4 shadow-sm">
  <h5>Upload Text File in Batches</h5>
  <div class="mb-3">
    <input class="form-control" type="file" id="fileInput" accept=".txt" />
  </div>
  <button id="uploadFileBtn" class="btn btn-primary" disabled>
    Upload File in Batches
  </button>
  <div id="status" class="mt-2 fw-bold"></div>
  <ul id="idList" class="list-group mt-2"></ul>
  <button id="copyBtn" class="btn btn-success mt-2" style="display: none">
    Copy All IDs
  </button>
</div>

<!-- -------- Scripts -------- -->
<script>
  // ------------------- Textarea Functions -------------------
  function clearContent() {
    document.getElementById("contentArea").value = "";
  }

  function copyContent() {
    const area = document.getElementById("contentArea");
    area.select();
    document.execCommand("copy");
    alert("Copied to clipboard!");
  }

  function pasteContent() {
    navigator.clipboard.readText().then((text) => {
      document.getElementById("contentArea").value = text;
    });
  }

  function uploadRaw() {
    const content = document.getElementById("contentArea").value.trim();
    if (!content) {
      alert("Content is empty!");
      return;
    }

    fetch("/api/upload/raw", {
      method: "POST",
      body: content,
      headers: { "Content-Type": "text/plain" },
    })
      .then((res) => res.json())
      .then((data) => {
        if (data.status === "success") {
          alert("Uploaded! Your key: " + data.key);
          window.location.href = "/" + data.key;
        } else alert("Error: " + data.message);
      })
      .catch((err) => alert("An error occurred."));
  }

  // ------------------- Existing Text File Batch Upload -------------------
  const fileInput = document.getElementById("fileInput");
  const uploadFileBtn = document.getElementById("uploadFileBtn");
  const statusDiv = document.getElementById("status");
  const idList = document.getElementById("idList");
  const copyBtn = document.getElementById("copyBtn");
  let textContent = "";

  fileInput.addEventListener("change", () => {
    const file = fileInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      textContent = e.target.result;
      statusDiv.textContent = `File loaded (${textContent.length} chars). Ready to upload.`;
      uploadFileBtn.disabled = false;
    };
    reader.readAsText(file);
  });

  uploadFileBtn.addEventListener("click", async () => {
    if (!textContent) return alert("Please select a file first.");
    uploadFileBtn.disabled = true;
    idList.innerHTML = "";
    copyBtn.style.display = "none";

    const CHUNK = 80000;
    const total = Math.ceil(textContent.length / CHUNK);
    const ids = [];

    for (let i = 0; i < total; i++) {
      const chunk = textContent.slice(i * CHUNK, (i + 1) * CHUNK);
      statusDiv.textContent = `Uploading batch ${i + 1} of ${total}...`;

      try {
        const res = await fetch("/api/upload/raw", {
          method: "POST",
          headers: { "Content-Type": "text/plain" },
          body: chunk,
        });
        const data = await res.json();
        const li = document.createElement("li");
        li.classList.add("list-group-item");

        if (data.status === "success") {
          const fullUrl = `${window.location.origin}/${data.key}`;
          ids.push(fullUrl);
          li.innerHTML = `<a href="${fullUrl}" target="_blank">${fullUrl}</a>`;
        } else {
          li.textContent = `Error in batch ${i + 1}: ${data.message}`;
          li.classList.add("list-group-item-danger");
        }
        idList.appendChild(li);
      } catch (err) {
        const li = document.createElement("li");
        li.textContent = `Error in batch ${i + 1}: ${err.message}`;
        li.classList.add("list-group-item-danger");
        idList.appendChild(li);
      }
    }

    statusDiv.textContent = `Upload complete! ${ids.length}/${total} batches uploaded.`;
    copyBtn.style.display = "inline-block";
    copyBtn.onclick = () => {
      navigator.clipboard.writeText(ids.join("\n"));
      copyBtn.textContent = "Copied!";
      setTimeout(() => (copyBtn.textContent = "Copy All IDs"), 1500);
    };
  });

  // ------------------- ZIP -> Text -> Batch Upload -------------------
  const zipFileInput = document.getElementById("zipFileInput");
  const zipToTextBtn = document.getElementById("zipToTextBtn");
  const zipStatus = document.getElementById("zipStatus");
  const zipIdList = document.getElementById("zipIdList");
  const zipCopyBtn = document.getElementById("zipCopyBtn");

  zipToTextBtn.addEventListener("click", async () => {
    if (!zipFileInput.files.length) return alert("Please select a ZIP file.");
    const file = zipFileInput.files[0];
    const reader = new FileReader();

    reader.onload = async (e) => {
      const arrayBuffer = e.target.result;
      const bytes = new Uint8Array(arrayBuffer);
      let binary = "";
      bytes.forEach((b) => (binary += String.fromCharCode(b)));
      const base64Text = btoa(binary);

      const CHUNK = 80000;
      const total = Math.ceil(base64Text.length / CHUNK);
      const ids = [];
      zipIdList.innerHTML = "";
      zipCopyBtn.style.display = "none";

      // üß† STEP 1: Send first batch as test
      zipStatus.textContent = "Sending first batch (test to check proxy)...";
      const firstChunk = base64Text.slice(0, CHUNK);
      let firstBatchBlocked = false;
      let firstBatchUrl = null;

      try {
        const res = await fetch("/api/upload/raw", {
          method: "POST",
          headers: { "Content-Type": "text/plain" },
          body: firstChunk,
        });
        const data = await res.json();
        const li = document.createElement("li");
        li.classList.add("list-group-item");

        if (data.status === "success") {
          // ‚úÖ Proxy is already active
          firstBatchUrl = `${window.location.origin}/api/get/${data.key}`;
          ids.push(firstBatchUrl);
          li.innerHTML = `<a href="${firstBatchUrl}" target="_blank">${firstBatchUrl}</a> (first batch OK)`;
          zipIdList.appendChild(li);
          zipStatus.textContent = "Proxy open ‚Äî continuing normal upload...";
        } else {
          throw new Error(data.message || "Unexpected error");
        }
      } catch (err) {
        // ‚ùå Blocked ‚Äî we‚Äôll retry first batch after others
        firstBatchBlocked = true;
        const li = document.createElement("li");
        li.textContent = "First batch blocked (proxy cold) ‚Äî will retry after others...";
        li.classList.add("list-group-item-warning");
        zipIdList.appendChild(li);
        zipStatus.textContent = "Uploading other batches first...";
      }

      // üß† STEP 2: Upload other batches (skip first if not blocked)
      const startIndex = firstBatchBlocked ? 1 : 1;
      for (let i = startIndex; i < total; i++) {
        const chunk = base64Text.slice(i * CHUNK, (i + 1) * CHUNK);
        zipStatus.textContent = `Uploading batch ${i + 1} of ${total}...`;

        try {
          const res = await fetch("/api/upload/raw", {
            method: "POST",
            headers: { "Content-Type": "text/plain" },
            body: chunk,
          });
          const data = await res.json();
          const li = document.createElement("li");
          li.classList.add("list-group-item");

          if (data.status === "success") {
            const fullUrl = `${window.location.origin}/api/get/${data.key}`;
            ids.push(fullUrl);
            li.innerHTML = `<a href="${fullUrl}" target="_blank">${fullUrl}</a>`;
          } else {
            li.textContent = `Error in batch ${i + 1}: ${data.message}`;
            li.classList.add("list-group-item-danger");
          }
          zipIdList.appendChild(li);
        } catch (err) {
          const li = document.createElement("li");
          li.textContent = `Error in batch ${i + 1}: ${err.message}`;
          li.classList.add("list-group-item-danger");
          zipIdList.appendChild(li);
        }
      }

      // üß† STEP 3: Retry first batch if it was blocked
      if (firstBatchBlocked) {
        zipStatus.textContent = `Retrying first batch (batch ${total + 1})...`;
        try {
          const res = await fetch("/api/upload/raw", {
            method: "POST",
            headers: { "Content-Type": "text/plain" },
            body: firstChunk,
          });
          const data = await res.json();
          const li = document.createElement("li");
          li.classList.add("list-group-item");

          if (data.status === "success") {
            firstBatchUrl = `${window.location.origin}/api/get/${data.key}`;
            // Insert first batch URL at the beginning to maintain order
            ids.unshift(firstBatchUrl);
            li.innerHTML = `<a href="${firstBatchUrl}" target="_blank">${firstBatchUrl}</a> (first batch retry OK)`;
            // Insert at the top of the list for visual order
            zipIdList.insertBefore(li, zipIdList.firstChild);
          } else {
            li.textContent = `Error in first batch retry: ${data.message}`;
            li.classList.add("list-group-item-danger");
            zipIdList.appendChild(li);
          }
        } catch (err) {
          const li = document.createElement("li");
          li.textContent = `Error in first batch retry: ${err.message}`;
          li.classList.add("list-group-item-danger");
          zipIdList.appendChild(li);
        }
      }

      // üß† STEP 4: Wrap up
      zipStatus.textContent = `Upload complete! ${ids.length} of ${total} batches uploaded.`;
      zipCopyBtn.style.display = "inline-block";
      zipCopyBtn.onclick = () => {
        navigator.clipboard.writeText(ids.join("\n"));
        zipCopyBtn.textContent = "Copied!";
        setTimeout(
          () => (zipCopyBtn.textContent = "Copy All Paste URLs"),
          1500
        );
      };
    };

    reader.readAsArrayBuffer(file);
  });

  // ------------------- Multi-URL Fetch -> Single ZIP -------------------
  const pasteUrlInput = document.getElementById("pasteUrlInput");
  const urlToZipBtn = document.getElementById("urlToZipBtn");

  urlToZipBtn.addEventListener("click", async () => {
    let urls = pasteUrlInput.value
      .split("\n")
      .map((u) => u.trim())
      .filter((u) => u.length > 0);

    if (!urls.length) return alert("Please enter at least one URL.");

    urlToZipBtn.disabled = true;
    urlToZipBtn.textContent = "Fetching & Combining...";

    try {
      let allBytes = [];

      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];

        await fetch(url)
          .then((res) => {
            if (!res.ok)
              throw new Error(`Failed to fetch ${url}. Status: ${res.status}`);
            return res.json();
          })
          .then((data) => {
            const base64Data = data.content;
            const binaryString = atob(base64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let j = 0; j < binaryString.length; j++) {
              bytes[j] = binaryString.charCodeAt(j);
            }
            allBytes.push(...bytes);
          })
          .catch((err) => {
            console.error(`Error fetching URL ${url}:`, err);
          });
      }

      const finalBytes = new Uint8Array(allBytes);
      const blob = new Blob([finalBytes], { type: "application/zip" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "combined.zip";
      a.click();
      URL.revokeObjectURL(a.href);
    } catch (err) {
      console.error("Error fetching URLs:", err);
      alert(`Error: ${err.message}`);
    }

    urlToZipBtn.disabled = false;
    urlToZipBtn.textContent = "Fetch & Download Combined ZIP";
  });
</script>
{% endblock %}  <div class="mb-3">
    <label class="form-label">Upload ZIP File ‚Üí Convert & Upload as Text</label>
    <input type="file" id="zipFileInput" accept=".zip" class="form-control" />
    <button id="zipToTextBtn" class="btn btn-primary mt-2">
      Convert & Upload ZIP as Text
    </button>
  </div>

  <!-- Multi-URL Fetch ‚Üí Single ZIP -->
  <div class="mb-3">
    <label class="form-label"
      >Paste multiple URLs (one per line) ‚Üí Combined ZIP</label
    >
    <textarea
      id="pasteUrlInput"
      rows="5"
      class="form-control"
      placeholder="Enter one URL per line"
    ></textarea>
    <button id="urlToZipBtn" class="btn btn-secondary mt-2">
      Fetch & Download Combined ZIP
    </button>
  </div>

  <div id="zipStatus" class="mt-2 fw-bold"></div>
  <ul id="zipIdList" class="list-group mt-2"></ul>
  <button id="zipCopyBtn" class="btn btn-success mt-2" style="display: none">
    Copy All Paste URLs
  </button>
</div>

<!-- -------- Existing File Upload in Batches -------- -->
<div class="card p-3 mb-4 shadow-sm">
  <h5>Upload Text File in Batches</h5>
  <div class="mb-3">
    <input class="form-control" type="file" id="fileInput" accept=".txt" />
  </div>
  <button id="uploadFileBtn" class="btn btn-primary" disabled>
    Upload File in Batches
  </button>
  <div id="status" class="mt-2 fw-bold"></div>
  <ul id="idList" class="list-group mt-2"></ul>
  <button id="copyBtn" class="btn btn-success mt-2" style="display: none">
    Copy All IDs
  </button>
</div>

<!-- -------- Scripts -------- -->
<script>
  // ------------------- Textarea Functions -------------------
  function clearContent() {
    document.getElementById("contentArea").value = "";
  }

  function copyContent() {
    const area = document.getElementById("contentArea");
    area.select();
    document.execCommand("copy");
    alert("Copied to clipboard!");
  }

  function pasteContent() {
    navigator.clipboard.readText().then((text) => {
      document.getElementById("contentArea").value = text;
    });
  }

  function uploadRaw() {
    const content = document.getElementById("contentArea").value.trim();
    if (!content) {
      alert("Content is empty!");
      return;
    }

    fetch("/api/upload/raw", {
      method: "POST",
      body: content,
      headers: { "Content-Type": "text/plain" },
    })
      .then((res) => res.json())
      .then((data) => {
        if (data.status === "success") {
          alert("Uploaded! Your key: " + data.key);
          window.location.href = "/" + data.key;
        } else alert("Error: " + data.message);
      })
      .catch((err) => alert("An error occurred."));
  }

  // ------------------- Existing Text File Batch Upload -------------------
  const fileInput = document.getElementById("fileInput");
  const uploadFileBtn = document.getElementById("uploadFileBtn");
  const statusDiv = document.getElementById("status");
  const idList = document.getElementById("idList");
  const copyBtn = document.getElementById("copyBtn");
  let textContent = "";

  fileInput.addEventListener("change", () => {
    const file = fileInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      textContent = e.target.result;
      statusDiv.textContent = `File loaded (${textContent.length} chars). Ready to upload.`;
      uploadFileBtn.disabled = false;
    };
    reader.readAsText(file);
  });

  uploadFileBtn.addEventListener("click", async () => {
    if (!textContent) return alert("Please select a file first.");
    uploadFileBtn.disabled = true;
    idList.innerHTML = "";
    copyBtn.style.display = "none";

    const CHUNK = 80000;
    const total = Math.ceil(textContent.length / CHUNK);
    const ids = [];

    for (let i = 0; i < total; i++) {
      const chunk = textContent.slice(i * CHUNK, (i + 1) * CHUNK);
      statusDiv.textContent = `Uploading batch ${i + 1} of ${total}...`;

      try {
        const res = await fetch("/api/upload/raw", {
          method: "POST",
          headers: { "Content-Type": "text/plain" },
          body: chunk,
        });
        const data = await res.json();
        const li = document.createElement("li");
        li.classList.add("list-group-item");

        if (data.status === "success") {
          const fullUrl = `${window.location.origin}/${data.key}`;
          ids.push(fullUrl);
          li.innerHTML = `<a href="${fullUrl}" target="_blank">${fullUrl}</a>`;
        } else {
          li.textContent = `Error in batch ${i + 1}: ${data.message}`;
          li.classList.add("list-group-item-danger");
        }
        idList.appendChild(li);
      } catch (err) {
        const li = document.createElement("li");
        li.textContent = `Error in batch ${i + 1}: ${err.message}`;
        li.classList.add("list-group-item-danger");
        idList.appendChild(li);
      }
    }

    statusDiv.textContent = `Upload complete! ${ids.length}/${total} batches uploaded.`;
    copyBtn.style.display = "inline-block";
    copyBtn.onclick = () => {
      navigator.clipboard.writeText(ids.join("\n"));
      copyBtn.textContent = "Copied!";
      setTimeout(() => (copyBtn.textContent = "Copy All IDs"), 1500);
    };
  });

  // ------------------- ZIP -> Text -> Batch Upload -------------------
  const zipFileInput = document.getElementById("zipFileInput");
  const zipToTextBtn = document.getElementById("zipToTextBtn");
  const zipStatus = document.getElementById("zipStatus");
  const zipIdList = document.getElementById("zipIdList");
  const zipCopyBtn = document.getElementById("zipCopyBtn");

  zipToTextBtn.addEventListener("click", async () => {
    if (!zipFileInput.files.length) return alert("Please select a ZIP file.");
    const file = zipFileInput.files[0];
    const reader = new FileReader();

    reader.onload = async (e) => {
      const arrayBuffer = e.target.result;
      const bytes = new Uint8Array(arrayBuffer);
      let binary = "";
      bytes.forEach((b) => (binary += String.fromCharCode(b)));
      const base64Text = btoa(binary);

      const CHUNK = 80000;
      const total = Math.ceil(base64Text.length / CHUNK);
      const ids = [];
      zipIdList.innerHTML = "";
      zipCopyBtn.style.display = "none";

      // üß† STEP 1: Send first batch as test
      zipStatus.textContent = "Sending first batch (test to check proxy)...";
      const firstChunk = base64Text.slice(0, CHUNK);
      let firstBatchBlocked = false;

      try {
        const res = await fetch("/api/upload/raw", {
          method: "POST",
          headers: { "Content-Type": "text/plain" },
          body: firstChunk,
        });
        const data = await res.json();
        const li = document.createElement("li");
        li.classList.add("list-group-item");

        if (data.status === "success") {
          // ‚úÖ Proxy is already active
          const fullUrl = `${window.location.origin}/api/get/${data.key}`;
          ids.push(fullUrl);
          li.innerHTML = `<a href="${fullUrl}" target="_blank">${fullUrl}</a> (first batch OK)`;
          zipIdList.appendChild(li);
          zipStatus.textContent = "Proxy open ‚Äî continuing normal upload...";
        } else {
          throw new Error(data.message || "Unexpected error");
        }
      } catch (err) {
        // ‚ùå Blocked ‚Äî we‚Äôll retry all batches again
        firstBatchBlocked = true;
        const li = document.createElement("li");
        li.textContent = "First batch blocked (proxy cold) ‚Äî retrying...";
        li.classList.add("list-group-item-warning");
        zipIdList.appendChild(li);
        zipStatus.textContent = "Retrying full upload from first batch...";
      }

      // üß† STEP 2: Decide upload start point
      const startIndex = firstBatchBlocked ? 0 : 1;

      // üß† STEP 3: Upload remaining (or all if retry)
      for (let i = startIndex; i < total; i++) {
        const chunk = base64Text.slice(i * CHUNK, (i + 1) * CHUNK);
        zipStatus.textContent = `Uploading batch ${i + 1} of ${total}...`;

        try {
          const res = await fetch("/api/upload/raw", {
            method: "POST",
            headers: { "Content-Type": "text/plain" },
            body: chunk,
          });
          const data = await res.json();
          const li = document.createElement("li");
          li.classList.add("list-group-item");

          if (data.status === "success") {
            const fullUrl = `${window.location.origin}/api/get/${data.key}`;
            ids.push(fullUrl);
            li.innerHTML = `<a href="${fullUrl}" target="_blank">${fullUrl}</a>`;
          } else {
            li.textContent = `Error in batch ${i + 1}: ${data.message}`;
            li.classList.add("list-group-item-danger");
          }
          zipIdList.appendChild(li);
        } catch (err) {
          const li = document.createElement("li");
          li.textContent = `Error in batch ${i + 1}: ${err.message}`;
          li.classList.add("list-group-item-danger");
          zipIdList.appendChild(li);
        }
      }

      // üß† STEP 4: Wrap up
      zipStatus.textContent = `Upload complete! ${ids.length} of ${total} batches uploaded.`;
      zipCopyBtn.style.display = "inline-block";
      zipCopyBtn.onclick = () => {
        navigator.clipboard.writeText(ids.join("\n"));
        zipCopyBtn.textContent = "Copied!";
        setTimeout(
          () => (zipCopyBtn.textContent = "Copy All Paste URLs"),
          1500
        );
      };
    };

    reader.readAsArrayBuffer(file);
  });

  const pasteUrlInput = document.getElementById("pasteUrlInput");
  const urlToZipBtn = document.getElementById("urlToZipBtn");

  urlToZipBtn.addEventListener("click", async () => {
    let urls = pasteUrlInput.value
      .split("\n")
      .map((u) => u.trim())
      .filter((u) => u.length > 0);

    if (!urls.length) return alert("Please enter at least one URL.");

    urlToZipBtn.disabled = true;
    urlToZipBtn.textContent = "Fetching & Combining...";

    try {
      let allBytes = [];

      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];

        await fetch(url)
          .then((res) => {
            if (!res.ok)
              throw new Error(`Failed to fetch ${url}. Status: ${res.status}`);
            return res.json(); // parse JSON
          })
          .then((data) => {
            const base64Data = data.content; // Base64 string from server
            // Decode Base64 to bytes
            const binaryString = atob(base64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let j = 0; j < binaryString.length; j++) {
              bytes[j] = binaryString.charCodeAt(j);
            }
            allBytes.push(...bytes); // append to single array
          })
          .catch((err) => {
            console.error(`Error fetching URL ${url}:`, err);
          });
      }

      // After all URLs are processed, create final ZIP blob
      const finalBytes = new Uint8Array(allBytes);
      const blob = new Blob([finalBytes], { type: "application/zip" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "combined.zip";
      a.click();
      URL.revokeObjectURL(a.href);
    } catch (err) {
      console.error("Error fetching URLs:", err);
      alert(`Error: ${err.message}`);
    }

    urlToZipBtn.disabled = false;
    urlToZipBtn.textContent = "Fetch & Download Combined ZIP";
  });
</script>

{% endblock %}
